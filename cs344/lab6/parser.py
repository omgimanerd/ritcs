#!/usr/bin/env python3
#
# Kladoi parser written in Python.
# Author: Alvin Lin (axl1439)

from lexer import Lexer

# Lexemes as constants
BEGIN = 'begin'
END = 'end'
PASS = 'pass'
IF = 'if'
WHILE = 'while'
ASSIGN = ':='

# Token types as constants
IDENTIFIER = 'IDENTIFIER'
LITERAL = 'LITERAL'
OPERATION = 'OPERATION'

# Grammar elements as constants
PROGRAM = 'PROGRAM'
STMTSEQ = 'STMTSEQ'
ASSIGNMENT = 'ASSIGNMENT'
BINARYOP = 'BINARYOP'

"""
A class encapsulating a node in the abstract syntax tree generated by the
parser. This node will hold the grammar element it represents, the token or
lexeme associated with that grammar element, and the children of the grammar
element.
"""
class ParserNode:
    def __init__(self, grammar, data, children):
        self.grammar = grammar
        self.data = data
        self.children = children

    def __str__(self):
        return '{} {} (Children: {})'.format(
            self.grammar, self.data, len(self.children))

"""
A class that takes a Kladoi program as text and uses the lexer to retrieve a
token stream from it, which it then uses to construct an abstract syntax tree.
"""
class Parser:
    def __init__(self, text, debug=False):
        self.debug = debug
        self.lexer = Lexer(text)
        self.stream = self.lexer.get_token_stream()
        self.tree = None

    def syntax_error(self):
        raise SyntaxError('Line {}: Syntax Error'.format(self.lexer.line))

    def peek(self):
        if len(self.stream) == 0:
            self.syntax_error()
        return self.stream[0]

    def pop(self):
        if len(self.stream) == 0:
            self.syntax_error()
        return self.stream.pop(0)

    def program(self):
        if self.debug:
            print('PROGRAM')
        if self.peek().lexeme == BEGIN:
            self.pop()
            node = ParserNode(PROGRAM, None, [self.statement_sequence()])
            if self.peek().lexeme == END:
                self.pop()
            else:
                self.syntax_error()
        else:
            node = ParserNode(PROGRAM, None, [self.statement()])
        return node

    def statement_sequence(self):
        if self.debug:
            print('STATEMENT SEQUENCE')
        children = [self.statement()]
        if self.peek().lexeme != END:
            children.append(self.statement_sequence())
        return ParserNode(STMTSEQ, None, children)

    def statement(self):
        if self.debug:
            print('STATEMENT')
        item = self.peek()
        if item.lexeme == IF:
            return ParserNode(IF, item, self.if_keyword())
        elif item.lexeme == WHILE:
            return ParserNode(WHILE, item, self.while_keyword())
        elif item.lexeme == PASS:
            self.pop()
            return ParserNode(PASS, item, [])
        elif item.token == IDENTIFIER:
            return self.assign()
        else:
            self.syntax_error()

    def assign(self):
        if self.debug:
            print('ASSIGN')
        identifier = self.pop()
        assignment_operator = self.pop()
        if assignment_operator.lexeme != ASSIGN:
            self.syntax_error()
        return ParserNode(ASSIGNMENT, identifier, [self.expression()])

    def if_keyword(self):
        if self.debug:
            print('IF')
        keyword = self.pop()
        return [self.expression(), self.program(), self.program()]

    def while_keyword(self):
        if self.debug:
            print('WHILE')
        keyword = self.pop()
        return [self.expression(), self.program()]

    def expression(self):
        if self.debug:
            print('EXPRESSION')
        item = self.pop()
        if item.token == IDENTIFIER:
            return ParserNode(IDENTIFIER, item, [])
        elif item.token == LITERAL:
            return ParserNode(LITERAL, item, [])
        elif item.token == OPERATION:
            return ParserNode(
                BINARYOP, item, [self.expression(), self.expression()])

    def parse_program(self):
        try:
            self.tree = self.program()
            if len(self.stream) != 0:
                raise SyntaxError(
                    'Line {}: Extra code at end of program'.format(
                        self.lexer.line - 1))
        except SyntaxError as e:
            print(e)
        return self.tree

    @staticmethod
    def preorder_format(root, accum, indent):
        if root:
            if root.grammar == ASSIGNMENT:
                accum += '{} := '.format(root.data.lexeme)
                accum += Parser.preorder_format(root.children[0], '', indent)
                accum += '\n' + '\t' * indent
            elif root.grammar == PASS:
                pass
            elif root.grammar == WHILE:
                accum += root.data.lexeme + ' '
                accum += Parser.preorder_format(root.children[0], '', indent)
                accum += '\n' + ('\t' * (indent + 1))
                accum += Parser.preorder_format(
                    root.children[1], '', indent + 1)
                accum += '\n' + '\t' * indent
            elif root.grammar == IF:
                accum += root.data.lexeme + ' '
                accum += Parser.preorder_format(root.children[0], '', indent)
                accum += '\n' + ('\t' * (indent + 1))
                accum += "True: "
                accum += Parser.preorder_format(
                    root.children[1], '', indent + 1)
                accum += "False: "
                accum += Parser.preorder_format(
                    root.children[2], '', indent + 1)
                accum += '\n' + '\t' * indent
            else:
                if root.data:
                    accum += root.data.lexeme + ' '
                for child in root.children:
                    accum += Parser.preorder_format(child, '', indent)
        return accum

if __name__ == '__main__':
    import sys
    if len(sys.argv) == 2:
        with open(sys.argv[1]) as f:
            parser = Parser(f.read())
    else:
        parser = Parser(sys.stdin.read())
    parser.parse_program()
    print(Parser.preorder_format(parser.tree, '', 0).strip())
